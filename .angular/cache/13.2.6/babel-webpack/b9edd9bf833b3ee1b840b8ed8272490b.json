{"ast":null,"code":"import { InjectionToken, NgZone, Injectable, Inject, ElementRef, Directive, Input, NgModule } from '@angular/core';\nimport { Subscriber, ReplaySubject, Subscription, BehaviorSubject } from 'rxjs';\nimport { take, switchMapTo, map, distinctUntilChanged } from 'rxjs/operators';\nimport { createDragDropManager } from 'dnd-core';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * The injection token for the dnd-core compatible backend currently in use.\n * @type {?}\n */\n\nimport * as Éµngcc0 from '@angular/core';\nconst DRAG_DROP_BACKEND = new InjectionToken('dnd-core compatible backend');\n/**\n * The injection token for the dnd-core BackendFactory used to instantiate dnd-core.\n * @type {?}\n */\n\nconst DRAG_DROP_BACKEND_FACTORY = new InjectionToken('dnd-core compatible backend');\n/**\n * The injection token for the dnd-core compatible backend's options.\n * @type {?}\n */\n\nconst DRAG_DROP_BACKEND_OPTIONS = new InjectionToken('options for dnd-core compatible backend');\n/**\n * The injection token for the dnd-core compatible backend currently in use.\n * @type {?}\n */\n\nconst DRAG_DROP_BACKEND_DEBUG_MODE = new InjectionToken('should dnd-core run in debug mode?');\n/**\n * The injection token for the dnd-core DragDropManager\n * @type {?}\n */\n\nconst DRAG_DROP_MANAGER = new InjectionToken('dnd-core DragDropManager');\n/**\n * The injection token for the dnd-core compatible backend currently in use.\n * @type {?}\n */\n\nconst DRAG_DROP_GLOBAL_CONTEXT = new InjectionToken('dnd-core context');\n/**\n * The type a source or target is given as a marker for 'you supplied null as a type',\n *  so that library consumers can be reminded to use setType/setTypes manually.\n *  See {\\@link DragSource#setType}, {\\@link DropTarget#setTypes}.\n * @type {?}\n */\n\nconst TYPE_DYNAMIC = Symbol('no type specified, you must provide one with setType/setTypes');\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} objA\n * @param {?} objB\n * @return {?}\n */\n\nfunction shallowEqual(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n  /** @type {?} */\n\n\n  const keysA = Object.keys(objA);\n  /** @type {?} */\n\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  } // Test for A's keys different from B.\n\n  /** @type {?} */\n\n\n  const hasOwn = Object.prototype.hasOwnProperty;\n\n  for (let i = 0; i < keysA.length; i += 1) {\n    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {\n      return false;\n    }\n    /** @type {?} */\n\n\n    const valA = objA[keysA[i]];\n    /** @type {?} */\n\n    const valB = objB[keysA[i]];\n\n    if (valA !== valB) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} nextOptions\n * @param {?} currentOptions\n * @return {?}\n */\n\n\nfunction areOptionsEqual(nextOptions, currentOptions) {\n  if (currentOptions === nextOptions) {\n    return true;\n  }\n\n  return currentOptions !== null && nextOptions !== null && shallowEqual(currentOptions, nextOptions);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template O\n */\n\n\nclass Reconnector {\n  /**\n   * @param {?} backendConnector\n   */\n  constructor(backendConnector) {\n    this.backendConnector = backendConnector;\n\n    this.reconnect =\n    /**\n    * @param {?} parentHandlerId\n    * @return {?}\n    */\n    parentHandlerId => {\n      if (this.disconnect) {\n        this.disconnect();\n        this.disconnect = null;\n      }\n\n      this.handlerId = parentHandlerId;\n\n      if (this.handlerId && this.node) {\n        this.disconnect = this.backendConnector(this.handlerId, this.node, this.options);\n      }\n    };\n\n    this.hook =\n    /**\n    * @param {?} nativeElement\n    * @param {?=} options\n    * @return {?}\n    */\n    (nativeElement, options) => {\n      if (nativeElement === this.node && areOptionsEqual(options, this.options)) {\n        return;\n      }\n\n      this.node = nativeElement;\n      this.options = options;\n      this.reconnect(this.handlerId);\n    };\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  Reconnector.prototype.handlerId;\n  /** @type {?} */\n\n  Reconnector.prototype.node;\n  /** @type {?} */\n\n  Reconnector.prototype.options;\n  /** @type {?} */\n\n  Reconnector.prototype.disconnect;\n  /** @type {?} */\n\n  Reconnector.prototype.reconnect;\n  /** @type {?} */\n\n  Reconnector.prototype.hook;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Reconnector.prototype.backendConnector;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass TargetConnector {\n  /**\n   * @param {?} backend\n   */\n  constructor(backend) {\n    this.backend = backend;\n    this.dropTarget = new Reconnector(\n    /**\n    * @param {?} handlerId\n    * @param {?} node\n    * @param {?} options\n    * @return {?}\n    */\n    (handlerId, node, options) => {\n      return this.backend.connectDropTarget(handlerId, node, options);\n    });\n    this.hooks = {\n      dropTarget: this.dropTarget.hook\n    };\n  }\n  /**\n   * @param {?} handlerId\n   * @return {?}\n   */\n\n\n  receiveHandlerId(handlerId) {\n    if (handlerId === this.currentHandlerId) {\n      return;\n    }\n\n    this.currentHandlerId = handlerId;\n    this.dropTarget.reconnect(handlerId);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  reconnect() {\n    this.dropTarget.reconnect(this.currentHandlerId);\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  TargetConnector.prototype.currentHandlerId;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TargetConnector.prototype.dropTarget;\n  /** @type {?} */\n\n  TargetConnector.prototype.hooks;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TargetConnector.prototype.backend;\n}\n/**\n * @param {?} backend\n * @return {?}\n */\n\n\nfunction createTargetConnector(backend) {\n  return new TargetConnector(backend);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} type\n * @param {?} target\n * @param {?} manager\n * @return {?}\n */\n\n\nfunction registerTarget(type, target, manager) {\n  /** @type {?} */\n  const registry = manager.getRegistry();\n  /** @type {?} */\n\n  const targetId = registry.addTarget(type, target);\n  /**\n   * @return {?}\n   */\n\n  function unregisterTarget() {\n    registry.removeTarget(targetId);\n  }\n\n  return {\n    handlerId: targetId,\n    unregister: unregisterTarget\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n * @template TConnector\n */\n\n\nfunction Connector() {}\n\nif (false) {\n  /** @type {?} */\n  Connector.prototype.hooks;\n  /**\n   * @param {?} handlerId\n   * @return {?}\n   */\n\n  Connector.prototype.receiveHandlerId = function (handlerId) {};\n  /**\n   * @return {?}\n   */\n\n\n  Connector.prototype.reconnect = function () {};\n}\n\nclass SourceConnector {\n  /**\n   * @param {?} backend\n   */\n  constructor(backend) {\n    this.backend = backend;\n    this.dragSource = new Reconnector(\n    /**\n    * @param {?} handlerId\n    * @param {?} node\n    * @param {?} options\n    * @return {?}\n    */\n    (handlerId, node, options) => {\n      return this.backend.connectDragSource(handlerId, node, options);\n    });\n    this.dragPreview = new Reconnector(\n    /**\n    * @param {?} handlerId\n    * @param {?} node\n    * @param {?} options\n    * @return {?}\n    */\n    (handlerId, node, options) => {\n      return this.backend.connectDragPreview(handlerId, node, options);\n    });\n    this.hooks = {\n      dragSource: this.dragSource.hook,\n      dragPreview: this.dragPreview.hook\n    };\n  }\n  /**\n   * @param {?} handlerId\n   * @return {?}\n   */\n\n\n  receiveHandlerId(handlerId) {\n    if (handlerId === this.currentHandlerId) {\n      return;\n    }\n\n    this.currentHandlerId = handlerId;\n    this.dragSource.reconnect(handlerId);\n    this.dragPreview.reconnect(handlerId);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  reconnect() {\n    this.dragSource.reconnect(this.currentHandlerId);\n    this.dragPreview.reconnect(this.currentHandlerId);\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  SourceConnector.prototype.currentHandlerId;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SourceConnector.prototype.dragSource;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SourceConnector.prototype.dragPreview;\n  /** @type {?} */\n\n  SourceConnector.prototype.hooks;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SourceConnector.prototype.backend;\n}\n/**\n * @param {?} backend\n * @return {?}\n */\n\n\nfunction createSourceConnector(backend) {\n  return new SourceConnector(backend);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} type\n * @param {?} source\n * @param {?} manager\n * @return {?}\n */\n\n\nfunction registerSource(type, source, manager) {\n  /** @type {?} */\n  const registry = manager.getRegistry();\n  /** @type {?} */\n\n  const sourceId = registry.addSource(type, source);\n  /**\n   * @return {?}\n   */\n\n  function unregisterSource() {\n    registry.removeSource(sourceId);\n  }\n\n  return {\n    handlerId: sourceId,\n    unregister: unregisterSource\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} assertion\n * @param {?} msg\n * @return {?}\n */\n\n\nfunction invariant(assertion, msg) {\n  if (!assertion) {\n    throw new Error(msg);\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\n\n\nfunction areCollectsEqual(a, b) {\n  if (a == null || b == null) {\n    return false;\n  }\n\n  if (typeof a !== 'object' || typeof b !== 'object') {\n    return a === b;\n  }\n\n  return shallowEqual(a, b);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @ignore\n * This is an RxJS operator to schedule a microtask just after all\n * the synchronous subscribers have been processed.\n * It's useful because we use `microTasks !== 0` to determine when we are finished\n * processing all the listeners and are ready for Angular to perform change detection.\n * @template T\n * @param {?} zone\n * @param {?=} uTask\n * @return {?}\n */\n\n\nfunction scheduleMicroTaskAfter(zone, uTask) {\n  return (\n    /**\n    * @param {?} source\n    * @return {?}\n    */\n    source => {\n      return source.lift(new RunInZoneOperator(zone, uTask));\n    }\n  );\n}\n/**\n * @ignore\n * @template T\n */\n\n\nclass ZoneSubscriber extends Subscriber {\n  /**\n   * @param {?} destination\n   * @param {?} zone\n   * @param {?=} uTask\n   */\n  constructor(destination, zone, uTask =\n  /**\n  * @return {?}\n  */\n  () => {}) {\n    super(destination);\n    this.zone = zone;\n    this.uTask = uTask;\n  }\n  /**\n   * @protected\n   * @param {?} val\n   * @return {?}\n   */\n\n\n  _next(val) {\n    this.destination.next && this.destination.next(val);\n    this.zone.scheduleMicroTask('ZoneSubscriber', this.uTask);\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ZoneSubscriber.prototype.zone;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ZoneSubscriber.prototype.uTask;\n}\n/**\n * @ignore\n * @template T, R\n */\n\n\nclass RunInZoneOperator {\n  /**\n   * @param {?} zone\n   * @param {?=} uTask\n   */\n  constructor(zone, uTask) {\n    this.zone = zone;\n    this.uTask = uTask;\n  }\n  /**\n   * @param {?} subscriber\n   * @param {?} source\n   * @return {?}\n   */\n\n\n  call(subscriber, source) {\n    return source.subscribe(new ZoneSubscriber(subscriber, this.zone, this.uTask));\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  RunInZoneOperator.prototype.zone;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RunInZoneOperator.prototype.uTask;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n * @template TMonitor, TConnector\n */\n\n\nfunction FactoryArgs() {}\n\nif (false) {\n  /** @type {?} */\n  FactoryArgs.prototype.createHandler;\n  /** @type {?} */\n\n  FactoryArgs.prototype.createMonitor;\n  /** @type {?} */\n\n  FactoryArgs.prototype.createConnector;\n  /** @type {?} */\n\n  FactoryArgs.prototype.registerHandler;\n}\n/**\n * @template TMonitor, TConnector\n */\n\n\nclass Connection {\n  /**\n   * @param {?} factoryArgs\n   * @param {?} manager\n   * @param {?} skyhookZone\n   * @param {?} initialType\n   */\n  constructor(factoryArgs, manager, skyhookZone, initialType) {\n    this.factoryArgs = factoryArgs;\n    this.manager = manager;\n    this.skyhookZone = skyhookZone;\n    /**\n     * A subject basically used to kick off any observables waiting for a type to be set via setType/setTypes\n     */\n\n    this.resolvedType$ = new ReplaySubject(1);\n    /**\n     * This one lives exactly as long as the connection.\n     * It is responsible for disposing of the handlerConnector, and any internal listen() subscriptions.\n     */\n\n    this.subscriptionConnectionLifetime = new Subscription();\n\n    this.onUpdate =\n    /**\n    * @return {?}\n    */\n    () => {\n      this.handlerConnector.reconnect();\n    };\n\n    this.handleChange =\n    /**\n    * @return {?}\n    */\n    () => {\n      this.collector$.next(this.handlerMonitor);\n    };\n\n    invariant(typeof manager === 'object', // TODO: update this mini-documentation\n    'Could not find the drag and drop manager in the context of %s. ' + 'Make sure to wrap the top-level component of your app with DragDropContext. ' // tslint:disable-next-line:max-line-length\n    // 'Read more: ',\n    );\n    NgZone.assertNotInAngularZone();\n    this.handlerMonitor = this.factoryArgs.createMonitor(this.manager);\n    this.collector$ = new BehaviorSubject(this.handlerMonitor);\n    this.handler = this.factoryArgs.createHandler(this.handlerMonitor);\n    this.handlerConnector = this.factoryArgs.createConnector(this.manager.getBackend()); // handlerConnector lives longer than any per-type subscription\n\n    this.subscriptionConnectionLifetime.add(\n    /**\n    * @return {?}\n    */\n    () => this.handlerConnector.receiveHandlerId(null));\n\n    if (initialType && initialType !== TYPE_DYNAMIC) {\n      this.setTypes(initialType);\n    }\n  }\n  /**\n   * @template P\n   * @param {?} mapFn\n   * @return {?}\n   */\n\n\n  listen(mapFn) {\n    // Listeners are generally around as long as the connection.\n    // This isn't 100% true, but there is no way of knowing (even if you ref-count it)\n    // when a component no longer needs it.\n    return this.resolvedType$.pipe( // this ensures we don't start emitting values until there is a type resolved\n    take(1), // switch our attention to the incoming firehose of 'something changed' events\n    switchMapTo(this.collector$), // turn them into 'interesting state' via the monitor and a user-provided function\n    map(mapFn), // don't emit EVERY time the firehose says something changed, only when the interesting state changes\n    distinctUntilChanged(areCollectsEqual), // this schedules a single batch change detection run after all the listeners have heard their newest value\n    // thus all changes resulting from subscriptions to this are caught by the\n    // change detector.\n    scheduleMicroTaskAfter(this.skyhookZone, this.onUpdate));\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n\n\n  connect(fn) {\n    /** @type {?} */\n    const subscription = this.resolvedType$.pipe(take(1)).subscribe(\n    /**\n    * @return {?}\n    */\n    () => {\n      // must run inside skyhookZone, so things like timers firing after a long hover with touch backend\n      // will cause change detection (via executing a macro or event task)\n      this.skyhookZone.run(\n      /**\n      * @return {?}\n      */\n      () => {\n        fn(this.handlerConnector.hooks);\n      });\n    }); // now chain this onto the connection's unsubscribe call.\n    // just in case you destroy your component before setting a type on anything\n    // i.e.:\n    // conn without a type\n    //     source = this.dnd.dragSource(null, { ... })\n    // manually connect to the DOM, which won't handle the returned subscription like the directive does\n    //     ngAfterViewInit() { this.source.connectDragSource(this.myDiv.nativeElement); }\n    // never set a type\n    // then destroy your component, the source, but not the connection request.\n    //     ngOnDestroy() { this.source.unsubscribe(); }\n    //\n    // without this, you would have a hanging resolvedType$.pipe(take(1)) subscription\n    // with this, it dies with the source's unsubscribe call.\n    //\n    // doesn't need this.subscriptionTypeLifetime, because pipe(take(1)) already does that\n\n    this.subscriptionConnectionLifetime.add(subscription);\n    return subscription;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n\n\n  connectDropTarget(node) {\n    return this.connect(\n    /**\n    * @param {?} c\n    * @return {?}\n    */\n    c =>\n    /** @type {?} */\n\n    /** @type {?} */\n    c.dropTarget(node));\n  }\n  /**\n   * @param {?} node\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  connectDragSource(node, options) {\n    return this.connect(\n    /**\n    * @param {?} c\n    * @return {?}\n    */\n    c =>\n    /** @type {?} */\n\n    /** @type {?} */\n    c.dragSource(node, options));\n  }\n  /**\n   * @param {?} node\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  connectDragPreview(node, options) {\n    return this.connect(\n    /**\n    * @param {?} c\n    * @return {?}\n    */\n    c =>\n    /** @type {?} */\n\n    /** @type {?} */\n    c.dragPreview(node, options));\n  }\n  /**\n   * @param {?} type\n   * @return {?}\n   */\n\n\n  setTypes(type) {\n    // must run inside skyhookZone, so things like timers firing after a long hover with touch backend\n    // will cause change detection (via executing a macro or event task)\n    this.skyhookZone.run(\n    /**\n    * @return {?}\n    */\n    () => {\n      this.receiveType(type);\n      this.resolvedType$.next(1);\n    });\n  }\n  /**\n   * @param {?} type\n   * @return {?}\n   */\n\n\n  setType(type) {\n    this.setTypes(type);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getHandlerId() {\n    return this.handlerId;\n  }\n  /**\n   * @param {?} type\n   * @return {?}\n   */\n\n\n  receiveType(type) {\n    if (type === this.currentType) {\n      return;\n    }\n\n    NgZone.assertNotInAngularZone();\n    this.currentType = type;\n\n    if (this.subscriptionTypeLifetime) {\n      this.subscriptionTypeLifetime.unsubscribe();\n    } // console.debug('subscribed to ' + type.toString());\n\n\n    this.subscriptionTypeLifetime = new Subscription();\n    const {\n      handlerId,\n      unregister\n    } = this.factoryArgs.registerHandler(type, this.handler, this.manager);\n    this.handlerId = handlerId;\n    this.handlerMonitor.receiveHandlerId(handlerId);\n    this.handlerConnector.receiveHandlerId(handlerId);\n    /** @type {?} */\n\n    const globalMonitor = this.manager.getMonitor();\n    /** @type {?} */\n\n    const unsubscribe = globalMonitor.subscribeToStateChange(this.handleChange, {\n      handlerIds: [handlerId]\n    });\n    this.subscriptionTypeLifetime.add(unsubscribe);\n    this.subscriptionTypeLifetime.add(unregister); // this.subscriptionTypeLifetime.add(() => console.debug(\"unsubscribed from \" + type.toString()));\n  }\n  /**\n   * @return {?}\n   */\n\n\n  unsubscribe() {\n    if (this.subscriptionTypeLifetime) {\n      this.subscriptionTypeLifetime.unsubscribe();\n    }\n\n    this.subscriptionConnectionLifetime.unsubscribe();\n  }\n  /**\n   * @param {?} teardown\n   * @return {?}\n   */\n\n\n  add(teardown) {\n    return this.subscriptionConnectionLifetime.add(teardown);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get closed() {\n    return this.subscriptionConnectionLifetime && this.subscriptionConnectionLifetime.closed;\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  Connection.prototype.handlerMonitor;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Connection.prototype.handlerConnector;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Connection.prototype.handler;\n  /**\n   * The stream of all change events from the internal subscription's handleChange\n   * @type {?}\n   * @private\n   */\n\n  Connection.prototype.collector$;\n  /**\n   * A subject basically used to kick off any observables waiting for a type to be set via setType/setTypes\n   * @type {?}\n   * @private\n   */\n\n  Connection.prototype.resolvedType$;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Connection.prototype.currentType;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Connection.prototype.handlerId;\n  /**\n   * This one is created and destroyed once per type or list of types.\n   * Because each time we change the type, we unsubscribe from the global state storage and\n   * re-subscribe with the new type.\n   * @type {?}\n   * @private\n   */\n\n  Connection.prototype.subscriptionTypeLifetime;\n  /**\n   * This one lives exactly as long as the connection.\n   * It is responsible for disposing of the handlerConnector, and any internal listen() subscriptions.\n   * @type {?}\n   * @private\n   */\n\n  Connection.prototype.subscriptionConnectionLifetime;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Connection.prototype.onUpdate;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Connection.prototype.handleChange;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Connection.prototype.factoryArgs;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Connection.prototype.manager;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Connection.prototype.skyhookZone;\n}\n/**\n * @record\n * @template Item, DropResult\n */\n\n\nfunction SourceConstructor() {}\n/**\n * @record\n */\n\n\nfunction TargetConstructor() {}\n/** @type {?} */\n\n\nconst TargetConnection =\n/** @type {?} */\nConnection;\n/** @type {?} */\n\nconst SourceConnection =\n/** @type {?} */\nConnection;\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nclass DragLayerConnectionClass {\n  /**\n   * @param {?} manager\n   * @param {?} zone\n   */\n  constructor(manager, zone) {\n    this.manager = manager;\n    this.zone = zone;\n    this.subscription = new Subscription();\n    this.isTicking = false;\n\n    this.handleStateChange =\n    /**\n    * @return {?}\n    */\n    () => {\n      /** @type {?} */\n      const monitor =\n      /** @type {?} */\n      this.manager.getMonitor();\n      this.collector$.next(monitor);\n    };\n\n    this.handleOffsetChange =\n    /**\n    * @return {?}\n    */\n    () => {\n      /** @type {?} */\n      const monitor =\n      /** @type {?} */\n      this.manager.getMonitor();\n      this.collector$.next(monitor);\n    };\n    /** @type {?} */\n\n\n    const monitor = this.manager.getMonitor();\n    this.collector$ = new BehaviorSubject(monitor);\n    this.unsubscribeFromOffsetChange = monitor.subscribeToOffsetChange(this.handleOffsetChange);\n    this.unsubscribeFromStateChange = monitor.subscribeToStateChange(this.handleStateChange);\n    this.subscription.add(\n    /**\n    * @return {?}\n    */\n    () => {\n      this.unsubscribeFromOffsetChange();\n      this.unsubscribeFromStateChange();\n    });\n    this.handleStateChange();\n  }\n  /**\n   * @template P\n   * @param {?} mapFn\n   * @return {?}\n   */\n\n\n  listen(mapFn) {\n    return this.collector$.pipe(map(mapFn), distinctUntilChanged(areCollectsEqual), scheduleMicroTaskAfter(this.zone));\n  }\n  /**\n   * @return {?}\n   */\n\n\n  unsubscribe() {\n    this.collector$.complete();\n    this.subscription.unsubscribe();\n  }\n  /**\n   * @param {?} teardown\n   * @return {?}\n   */\n\n\n  add(teardown) {\n    return this.subscription.add(teardown);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get closed() {\n    return this.subscription.closed;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  DragLayerConnectionClass.prototype.unsubscribeFromOffsetChange;\n  /** @type {?} */\n\n  DragLayerConnectionClass.prototype.unsubscribeFromStateChange;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DragLayerConnectionClass.prototype.collector$;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DragLayerConnectionClass.prototype.subscription;\n  /** @type {?} */\n\n  DragLayerConnectionClass.prototype.isTicking;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DragLayerConnectionClass.prototype.handleStateChange;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DragLayerConnectionClass.prototype.handleOffsetChange;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DragLayerConnectionClass.prototype.manager;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DragLayerConnectionClass.prototype.zone;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nlet isCallingCanDrag = false;\n/** @type {?} */\n\nlet isCallingIsDragging = false;\n\nclass DragSourceMonitorClass {\n  /**\n   * @param {?} manager\n   */\n  constructor(manager) {\n    this.internalMonitor = manager.getMonitor();\n  }\n  /**\n   * @param {?} sourceId\n   * @return {?}\n   */\n\n\n  receiveHandlerId(sourceId) {\n    this.sourceId = sourceId;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  canDrag() {\n    invariant(!isCallingCanDrag, 'You may not call monitor.canDrag() inside your canDrag() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source-monitor.html');\n\n    try {\n      isCallingCanDrag = true;\n      return this.internalMonitor.canDragSource(this.sourceId);\n    } finally {\n      isCallingCanDrag = false;\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  isDragging() {\n    invariant(!isCallingIsDragging, 'You may not call monitor.isDragging() inside your isDragging() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source-monitor.html');\n\n    try {\n      isCallingIsDragging = true;\n      return this.internalMonitor.isDraggingSource(this.sourceId);\n    } finally {\n      isCallingIsDragging = false;\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getItemType() {\n    return this.internalMonitor.getItemType();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getItem() {\n    return this.internalMonitor.getItem();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getDropResult() {\n    return this.internalMonitor.getDropResult();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  didDrop() {\n    return this.internalMonitor.didDrop();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getInitialClientOffset() {\n    return this.internalMonitor.getInitialClientOffset();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getInitialSourceClientOffset() {\n    return this.internalMonitor.getInitialSourceClientOffset();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getSourceClientOffset() {\n    return this.internalMonitor.getSourceClientOffset();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getClientOffset() {\n    return this.internalMonitor.getClientOffset();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getDifferenceFromInitialOffset() {\n    return this.internalMonitor.getDifferenceFromInitialOffset();\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  DragSourceMonitorClass.prototype.internalMonitor;\n  /** @type {?} */\n\n  DragSourceMonitorClass.prototype.sourceId;\n}\n/**\n * @param {?} manager\n * @return {?}\n */\n\n\nfunction createSourceMonitor(manager) {\n  return new DragSourceMonitorClass(manager);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass Target {\n  /**\n   * @param {?} spec\n   * @param {?} zone\n   * @param {?} monitor\n   */\n  constructor(spec, zone, monitor) {\n    this.spec = spec;\n    this.zone = zone;\n    this.monitor = monitor;\n    this.monitor = monitor;\n  }\n  /**\n   * @template T\n   * @param {?} fn\n   * @return {?}\n   */\n\n\n  withChangeDetection(fn) {\n    /** @type {?} */\n    let x = fn();\n    this.zone.scheduleMicroTask('DropTarget',\n    /**\n    * @return {?}\n    */\n    () => {});\n    return x;\n  }\n  /**\n   * @param {?} monitor\n   * @return {?}\n   */\n\n\n  receiveMonitor(monitor) {\n    this.monitor = monitor;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  canDrop() {\n    if (!this.spec.canDrop) {\n      return true;\n    } // don't run isDragging in the zone. Should be a pure function of `this`.\n\n\n    return this.spec.canDrop(this.monitor);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  hover() {\n    if (!this.spec.hover) {\n      return;\n    }\n\n    this.withChangeDetection(\n    /**\n    * @return {?}\n    */\n    () => {\n      this.spec.hover && this.spec.hover(this.monitor);\n    });\n  }\n  /**\n   * @return {?}\n   */\n\n\n  drop() {\n    if (!this.spec.drop) {\n      return undefined;\n    }\n\n    return this.withChangeDetection(\n    /**\n    * @return {?}\n    */\n    () => {\n      /** @type {?} */\n      const dropResult = this.spec.drop && this.spec.drop(this.monitor);\n      return dropResult;\n    });\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  Target.prototype.spec;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Target.prototype.zone;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Target.prototype.monitor;\n}\n/**\n * @param {?} spec\n * @param {?} zone\n * @return {?}\n */\n\n\nfunction createTargetFactory(spec, zone) {\n  return (\n    /**\n    * @param {?} monitor\n    * @return {?}\n    */\n    function createTarget(monitor) {\n      return new Target(spec, zone, monitor);\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nlet isCallingCanDrop = false;\n\nclass DropTargetMonitorClass {\n  /**\n   * @param {?} manager\n   */\n  constructor(manager) {\n    this.internalMonitor = manager.getMonitor();\n  }\n  /**\n   * @param {?} targetId\n   * @return {?}\n   */\n\n\n  receiveHandlerId(targetId) {\n    this.targetId = targetId;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  canDrop() {\n    invariant(!isCallingCanDrop, 'You may not call monitor.canDrop() inside your canDrop() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target-monitor.html');\n\n    try {\n      isCallingCanDrop = true;\n      return this.internalMonitor.canDropOnTarget(this.targetId);\n    } finally {\n      isCallingCanDrop = false;\n    }\n  }\n  /**\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  isOver(options = {\n    shallow: false\n  }) {\n    return this.internalMonitor.isOverTarget(this.targetId, options);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getItemType() {\n    return this.internalMonitor.getItemType();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getItem() {\n    return this.internalMonitor.getItem();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getDropResult() {\n    return this.internalMonitor.getDropResult();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  didDrop() {\n    return this.internalMonitor.didDrop();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getInitialClientOffset() {\n    return this.internalMonitor.getInitialClientOffset();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getInitialSourceClientOffset() {\n    return this.internalMonitor.getInitialSourceClientOffset();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getSourceClientOffset() {\n    return this.internalMonitor.getSourceClientOffset();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getClientOffset() {\n    return this.internalMonitor.getClientOffset();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getDifferenceFromInitialOffset() {\n    return this.internalMonitor.getDifferenceFromInitialOffset();\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  DropTargetMonitorClass.prototype.internalMonitor;\n  /** @type {?} */\n\n  DropTargetMonitorClass.prototype.targetId;\n}\n/**\n * @param {?} manager\n * @return {?}\n */\n\n\nfunction createTargetMonitor(manager) {\n  return new DropTargetMonitorClass(manager);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass Source {\n  /**\n   * @param {?} spec\n   * @param {?} zone\n   * @param {?} monitor\n   */\n  constructor(spec, zone, monitor) {\n    this.spec = spec;\n    this.zone = zone;\n    this.monitor = monitor;\n  }\n  /**\n   * @template T\n   * @param {?} fn\n   * @return {?}\n   */\n\n\n  withChangeDetection(fn) {\n    /** @type {?} */\n    let x = fn();\n    this.zone.scheduleMicroTask('DragSource',\n    /**\n    * @return {?}\n    */\n    () => {});\n    return x;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  canDrag() {\n    if (!this.spec.canDrag) {\n      return true;\n    }\n\n    return this.withChangeDetection(\n    /**\n    * @return {?}\n    */\n    () => {\n      return this.spec.canDrag && this.spec.canDrag(this.monitor) || false;\n    });\n  }\n  /**\n   * @param {?} globalMonitor\n   * @param {?} sourceId\n   * @return {?}\n   */\n\n\n  isDragging(globalMonitor, sourceId) {\n    if (!this.spec.isDragging) {\n      return sourceId === globalMonitor.getSourceId();\n    }\n\n    return this.spec.isDragging(this.monitor);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  beginDrag() {\n    return this.withChangeDetection(\n    /**\n    * @return {?}\n    */\n    () => {\n      return this.spec.beginDrag(this.monitor);\n    });\n  }\n  /**\n   * @return {?}\n   */\n\n\n  endDrag() {\n    if (!this.spec.endDrag) {\n      return;\n    }\n\n    return this.withChangeDetection(\n    /**\n    * @return {?}\n    */\n    () => {\n      if (this.spec.endDrag) {\n        this.spec.endDrag(this.monitor);\n      }\n    });\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  Source.prototype.spec;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Source.prototype.zone;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Source.prototype.monitor;\n}\n/**\n * @param {?} spec\n * @param {?} zone\n * @return {?}\n */\n\n\nfunction createSourceFactory(spec, zone) {\n  return (\n    /**\n    * @param {?} monitor\n    * @return {?}\n    */\n    function createSource(monitor) {\n      return new Source(spec, zone, monitor);\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Represents an RxJS Subscription, with multi-version compatibility.\n * The standard SubscriptionLike does not contain an add() method.\n * @record\n */\n\n\nfunction AddSubscription() {}\n\nif (false) {\n  /**\n   * Same as RxJS `Subscription#add`\n   * @param {?} teardownLogic\n   * @return {?}\n   */\n  AddSubscription.prototype.add = function (teardownLogic) {};\n}\n/**\n * For a simple component, unsubscribing is as easy as `connection.unsubscribe()` in `ngOnDestroy()`\n *  If your components have lots of subscriptions, it can get tedious having to\n *  unsubscribe from all of them, and you might forget. A common pattern is to create an RxJS Subscription\n *  (maybe called `destroy`), to use `this.destroy.add(xxx.subscribe(...))`\n *  and to call `destroy.unsubscribe()` once to clean up all of them. \\@angular-skyhook/core\n *  supports this pattern with by using the `subscription` parameter on the\n *  constructors. Simply:\n *\n * ```typescript\n * import { Subscription } from 'rxjs';\n * // ...\n * destroy = new Subscription();\n * target = this.dnd.dropTarget({\n * // ...\n * }, this.destroy);\n * ngOnDestroy() { this.destroy.unsubscribe(); }\n * ```\n *\n * It is a good habit for avoiding leaked subscriptions, because .\n */\n\n\nlet SkyhookDndService = /*#__PURE__*/(() => {\n  class SkyhookDndService {\n    /**\n     * @ignore\n     * @param {?} manager\n     * @param {?} ngZone\n     */\n    constructor(manager, ngZone) {\n      this.manager = manager;\n      this.ngZone = ngZone;\n      /**\n       * @ignore\n       */\n\n      this.skyhookZone = Zone.root.fork({\n        name: \"skyhookZone\",\n        onHasTask:\n        /**\n        * @param {?} _parentZoneDelegate\n        * @param {?} _currentZone\n        * @param {?} _targetZone\n        * @param {?} state\n        * @return {?}\n        */\n        (_parentZoneDelegate, _currentZone, _targetZone, state) => {\n          // when we've | drained the microTask queue; or                    | ... run a change detection cycle.\n          //            | executed or cancelled a macroTask (eg a timer); or |\n          //            | handled an event                                   |\n          // note: we must use ngZone.run() instead of ApplicationRef.tick()\n          // this is because\n          // 1. this callback runs outside the angular zone\n          // 2. therefore if you use appRef.tick(), the event handlers set up during the tick() are\n          //    not in the angular zone, even though anything set up during tick() should be\n          // 3. therefore you get regular (click) handlers from templates running in skyhookZone\n          //    and not causing change detection\n          // Also, now we watch for macroTasks as well.\n          // This means if we set up timers in the skyhook zone, they will fire and cause change\n          // detection. Useful if doing .listen(...).delay(1000) and the resulting asynchronous\n          // subscribers.\n          // Appropriately, we run more setup handlers in skyhookZone now.\n          //\n          // Proper event handlers (set up by the backend) don't trigger any, because skyhookZone\n          // only cares about # of handlers changing => 0. But if we care about them, it will be\n          // through listen(), updates to which will schedule a microTask.\n          if (!state[state.change]) {\n            this.ngZone.run(\n            /**\n            * @return {?}\n            */\n            () => {// noop, but causes change detection (i.e. onLeave)\n            });\n          }\n        } // onInvokeTask: (zoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) => {\n        // }\n        // onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n        //   return parentZoneDelegate.scheduleTask(targetZone, task);\n        // },\n        // onInvoke: (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) => {\n        // }\n\n      });\n    }\n    /**\n     * This drop target will only react to the items produced by the drag sources\n     * of the specified type or types.\n     *\n     * If you want a dynamic type, pass `null` as the type; and call\n     * {\\@link DropTarget#setTypes} in a lifecycle hook.\n     * @template Item, DropResult\n     * @param {?} types\n     * @param {?} spec\n     * @param {?=} subscription\n     * @return {?}\n     */\n\n\n    dropTarget(types, spec, subscription) {\n      // return this.ngZone.runOutsideAngular(() => {\n      return this.skyhookZone.run(\n      /**\n      * @return {?}\n      */\n      () => {\n        /** @type {?} */\n        const createTarget = createTargetFactory(spec, this.skyhookZone);\n        /** @type {?} */\n\n        const conn = new TargetConnection({\n          createHandler: createTarget,\n          registerHandler: registerTarget,\n          createMonitor: createTargetMonitor,\n          createConnector: createTargetConnector\n        }, this.manager, this.skyhookZone, types || TYPE_DYNAMIC);\n\n        if (subscription) {\n          subscription.add(conn);\n        }\n\n        return conn;\n      });\n    }\n    /**\n     * This method creates a {\\@link DragSource} object. It represents a drag\n     *  source and its behaviour, and can be connected to a DOM element by\n     *  assigning it to the `[dragSource]` directive on that element in your\n     *  template.\n     *\n     * It is the corollary of [`react-dnd`'s\n     * `DragSource`](http://react-dnd.github.io/react-dnd/docs-drag-source.html).\n     *\n     * The `spec` argument ({\\@link DragSourceSpec}) is a set of _queries_ and\n     * _callbacks_ that are called at appropriate times by the internals. The\n     * queries are for asking your component whether to drag/listen and what\n     * item data to hoist up; the callback (just 1) is for notifying you when\n     * the drag ends.\n     *\n     * Only the drop targets registered for the same type will\n     * react to the items produced by this drag source. If you want a dynamic\n     * type, pass `null` as the type; and call {\\@link DragSource#setType} in\n     * a lifecycle hook.\n     *\n     * @template Item, DropResult\n     * @param {?} type\n     * @param {?} spec\n     * @param {?=} subscription An RxJS Subscription to tie the lifetime of the\n     * connection to.\n     * @return {?}\n     */\n\n\n    dragSource(type, spec, subscription) {\n      // return this.ngZone.runOutsideAngular(() => {\n      return this.skyhookZone.run(\n      /**\n      * @return {?}\n      */\n      () => {\n        /** @type {?} */\n        const createSource = createSourceFactory(spec, this.skyhookZone);\n        /** @type {?} */\n\n        const conn = new SourceConnection({\n          createHandler: createSource,\n          registerHandler: registerSource,\n          createMonitor: createSourceMonitor,\n          createConnector: createSourceConnector\n        }, this.manager, this.skyhookZone, type || TYPE_DYNAMIC);\n\n        if (subscription) {\n          subscription.add(conn);\n        }\n\n        return conn;\n      });\n    }\n    /**\n     * This method creates a {\\@link DragLayer} object\n     * @template Item\n     * @param {?=} subscription\n     * @return {?}\n     */\n\n\n    dragLayer(subscription) {\n      // return this.ngZone.runOutsideAngular(() => {\n      return this.skyhookZone.run(\n      /**\n      * @return {?}\n      */\n      () => {\n        /** @type {?} */\n        const conn = new DragLayerConnectionClass(this.manager, this.skyhookZone);\n\n        if (subscription) {\n          subscription.add(conn);\n        }\n\n        return conn;\n      });\n    }\n\n  }\n\n  SkyhookDndService.Éµfac = function SkyhookDndService_Factory(t) {\n    return new (t || SkyhookDndService)(Éµngcc0.ÉµÉµinject(DRAG_DROP_MANAGER), Éµngcc0.ÉµÉµinject(Éµngcc0.NgZone));\n  };\n\n  SkyhookDndService.Éµprov = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjectable({\n    token: SkyhookDndService,\n    factory: SkyhookDndService.Éµfac\n  });\n  /** @nocollapse */\n\n  return SkyhookDndService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @ignore\n   * @type {?}\n   * @private\n   */\n  SkyhookDndService.prototype.skyhookZone;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SkyhookDndService.prototype.manager;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SkyhookDndService.prototype.ngZone;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @ignore\n * @type {?}\n */\n\n\nconst explanation = 'You can only pass exactly one connection object to [dropTarget]. ' + 'There is only one of each source/target/preview allowed per DOM element.';\n/**\n * @ignore\n * @abstract\n */\n\nlet DndDirective = /*#__PURE__*/(() => {\n  class DndDirective {\n    /**\n     * @ignore\n     * @param {?} elRef\n     * @param {?} zone\n     */\n    constructor(elRef, zone) {\n      this.elRef = elRef;\n      this.zone = zone;\n      this.deferredRequest = new Subscription();\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    ngOnChanges() {\n      invariant(typeof this.connection === 'object' && !Array.isArray(this.connection), explanation);\n      this.zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => {\n        // discard an unresolved connection request\n        // in the case where the previous one succeeded, deferredRequest is\n        // already closed.\n        this.deferredRequest.unsubscribe(); // replace it with a new one\n\n        if (this.connection) {\n          this.deferredRequest = this.callHooks(this.connection);\n        }\n      });\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.deferredRequest.unsubscribe();\n    }\n\n  }\n\n  DndDirective.Éµfac = function DndDirective_Factory(t) {\n    return new (t || DndDirective)(Éµngcc0.ÉµÉµinject(Éµngcc0.ElementRef), Éµngcc0.ÉµÉµinject(Éµngcc0.NgZone));\n  };\n\n  DndDirective.Éµprov = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjectable({\n    token: DndDirective,\n    factory: DndDirective.Éµfac\n  });\n  DndDirective.Éµdir = /*@__PURE__*/Éµngcc0.ÉµÉµdefineDirective({\n    type: DndDirective,\n    features: [Éµngcc0.ÉµÉµNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return DndDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @protected\n   */\n  DndDirective.prototype.connection;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DndDirective.prototype.deferredRequest;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  DndDirective.prototype.elRef;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DndDirective.prototype.zone;\n  /**\n   * @abstract\n   * @protected\n   * @param {?} conn\n   * @return {?}\n   */\n\n  DndDirective.prototype.callHooks = function (conn) {};\n} // Note: the T | undefined everywhere is from https://github.com/angular/angular-cli/issues/2034\n\n/**\n * Allows you to connect a {\\@link DropTarget} to an element in a component template.\n */\n\n\nlet DropTargetDirective = /*#__PURE__*/(() => {\n  class DropTargetDirective extends DndDirective {\n    /**\n     * Reduce typo confusion by allowing non-plural version of dropTargetTypes\n     * @param {?} t\n     * @return {?}\n     */\n    set dropTargetType(t) {\n      this.dropTargetTypes = t;\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    ngOnChanges() {\n      this.connection = this.dropTarget;\n\n      if (this.connection && this.dropTargetTypes != null) {\n        this.connection.setTypes(this.dropTargetTypes);\n      }\n\n      super.ngOnChanges();\n    }\n    /**\n     * @protected\n     * @param {?} conn\n     * @return {?}\n     */\n\n\n    callHooks(conn) {\n      return conn.connectDropTarget(this.elRef.nativeElement);\n    }\n\n  }\n\n  DropTargetDirective.Éµfac = /*@__PURE__*/function () {\n    let ÉµDropTargetDirective_BaseFactory;\n    return function DropTargetDirective_Factory(t) {\n      return (ÉµDropTargetDirective_BaseFactory || (ÉµDropTargetDirective_BaseFactory = Éµngcc0.ÉµÉµgetInheritedFactory(DropTargetDirective)))(t || DropTargetDirective);\n    };\n  }();\n\n  DropTargetDirective.Éµdir = /*@__PURE__*/Éµngcc0.ÉµÉµdefineDirective({\n    type: DropTargetDirective,\n    selectors: [[\"\", \"dropTarget\", \"\"]],\n    inputs: {\n      dropTargetType: \"dropTargetType\",\n      dropTargetTypes: \"dropTargetTypes\",\n      dropTarget: \"dropTarget\"\n    },\n    features: [Éµngcc0.ÉµÉµInheritDefinitionFeature, Éµngcc0.ÉµÉµNgOnChangesFeature]\n  });\n  return DropTargetDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @protected\n   */\n  DropTargetDirective.prototype.connection;\n  /**\n   * Which target to connect the DOM to\n   * @type {?}\n   */\n\n  DropTargetDirective.prototype.dropTarget;\n  /**\n   * Shortcut for setting a type on the connection.\n   *  Lets you use Angular binding to do it. Runs {\\@link DropTarget#setTypes}.\n   * @type {?}\n   */\n\n  DropTargetDirective.prototype.dropTargetTypes;\n}\n/**\n * Allows you to connect a {\\@link DragSource} to an element in a component template.\n */\n\n\nlet DragSourceDirective = /*#__PURE__*/(() => {\n  class DragSourceDirective extends DndDirective {\n    constructor() {\n      super(...arguments);\n      /**\n       * Do not render an HTML5 preview. Only applies when using the HTML5 backend.\n       * It does not use { captureDraggingState: true } for IE11 support; that is broken.\n       */\n\n      this.noHTML5Preview = false;\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    ngOnChanges() {\n      this.connection = this.dragSource;\n\n      if (this.connection && this.dragSourceType != null) {\n        this.connection.setType(this.dragSourceType);\n      }\n\n      super.ngOnChanges();\n    }\n    /**\n     * @protected\n     * @param {?} conn\n     * @return {?}\n     */\n\n\n    callHooks(conn) {\n      /** @type {?} */\n      const sub = new Subscription();\n      sub.add(conn.connectDragSource(this.elRef.nativeElement, this.dragSourceOptions));\n\n      if (this.noHTML5Preview) {\n        sub.add(conn.connectDragPreview(getEmptyImage()));\n      }\n\n      return sub;\n    }\n\n  }\n\n  DragSourceDirective.Éµfac = /*@__PURE__*/function () {\n    let ÉµDragSourceDirective_BaseFactory;\n    return function DragSourceDirective_Factory(t) {\n      return (ÉµDragSourceDirective_BaseFactory || (ÉµDragSourceDirective_BaseFactory = Éµngcc0.ÉµÉµgetInheritedFactory(DragSourceDirective)))(t || DragSourceDirective);\n    };\n  }();\n\n  DragSourceDirective.Éµdir = /*@__PURE__*/Éµngcc0.ÉµÉµdefineDirective({\n    type: DragSourceDirective,\n    selectors: [[\"\", \"dragSource\", \"\"]],\n    inputs: {\n      noHTML5Preview: \"noHTML5Preview\",\n      dragSource: \"dragSource\",\n      dragSourceType: \"dragSourceType\",\n      dragSourceOptions: \"dragSourceOptions\"\n    },\n    features: [Éµngcc0.ÉµÉµInheritDefinitionFeature, Éµngcc0.ÉµÉµNgOnChangesFeature]\n  });\n  return DragSourceDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @protected\n   */\n  DragSourceDirective.prototype.connection;\n  /**\n   * Which source to connect the DOM to\n   * @type {?}\n   */\n\n  DragSourceDirective.prototype.dragSource;\n  /**\n   * Shortcut for setting a type on the connection.\n   *  Lets you use Angular binding to do it. Runs {\\@link DragSource#setType}.\n   * @type {?}\n   */\n\n  DragSourceDirective.prototype.dragSourceType;\n  /**\n   * Pass an options object as you would to {\\@link DragSource#connectDragSource}.\n   * @type {?}\n   */\n\n  DragSourceDirective.prototype.dragSourceOptions;\n  /**\n   * Do not render an HTML5 preview. Only applies when using the HTML5 backend.\n   * It does not use { captureDraggingState: true } for IE11 support; that is broken.\n   * @type {?}\n   */\n\n  DragSourceDirective.prototype.noHTML5Preview;\n}\n/**\n * Allows you to specify which element a {\\@link DragSource} should screenshot as an HTML5 drag preview.\n *\n * Only relevant when using the HTML5 backend.\n */\n\n\nlet DragPreviewDirective = /*#__PURE__*/(() => {\n  class DragPreviewDirective extends DndDirective {\n    /**\n     * @protected\n     * @return {?}\n     */\n    ngOnChanges() {\n      this.connection = this.dragPreview;\n      super.ngOnChanges();\n    }\n    /**\n     * @protected\n     * @param {?} conn\n     * @return {?}\n     */\n\n\n    callHooks(conn) {\n      return conn.connectDragPreview(this.elRef.nativeElement, this.dragPreviewOptions);\n    }\n\n  }\n\n  DragPreviewDirective.Éµfac = /*@__PURE__*/function () {\n    let ÉµDragPreviewDirective_BaseFactory;\n    return function DragPreviewDirective_Factory(t) {\n      return (ÉµDragPreviewDirective_BaseFactory || (ÉµDragPreviewDirective_BaseFactory = Éµngcc0.ÉµÉµgetInheritedFactory(DragPreviewDirective)))(t || DragPreviewDirective);\n    };\n  }();\n\n  DragPreviewDirective.Éµdir = /*@__PURE__*/Éµngcc0.ÉµÉµdefineDirective({\n    type: DragPreviewDirective,\n    selectors: [[\"\", \"dragPreview\", \"\"]],\n    inputs: {\n      dragPreview: \"dragPreview\",\n      dragPreviewOptions: \"dragPreviewOptions\"\n    },\n    features: [Éµngcc0.ÉµÉµInheritDefinitionFeature, Éµngcc0.ÉµÉµNgOnChangesFeature]\n  });\n  return DragPreviewDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @protected\n   */\n  DragPreviewDirective.prototype.connection;\n  /**\n   * The drag source for which this element will be the preview.\n   * @type {?}\n   */\n\n  DragPreviewDirective.prototype.dragPreview;\n  /**\n   * Pass an options object as you would to {\\@link DragSource#connectDragPreview}.\n   * @type {?}\n   */\n\n  DragPreviewDirective.prototype.dragPreviewOptions;\n} // import { getEmptyImage } from 'react-dnd-html5-backend';\n// we don't want to depend on the backend, so here that is, copied\n\n/**\n * @ignore\n * @type {?}\n */\n\n\nlet emptyImage;\n/**\n * Returns a 0x0 empty GIF for use as a drag preview.\n * @ignore\n *\n * @return {?}\n */\n\nfunction getEmptyImage() {\n  if (!emptyImage) {\n    emptyImage = new Image();\n    emptyImage.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n  }\n\n  return emptyImage;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @ignore\n * @param {?} backendOrModule\n * @return {?}\n */\n\n\nfunction unpackBackendForEs5Users(backendOrModule) {\n  // Auto-detect ES6 default export for people still using ES5\n\n  /** @type {?} */\n  let backend = backendOrModule;\n\n  if (typeof backend === 'object' && typeof backend.default === 'function') {\n    backend = backend.default;\n  }\n\n  invariant(typeof backend === 'function', 'Expected the backend to be a function or an ES6 module exporting a default function. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-drop-context.html');\n  return backend;\n} // TODO allow injecting window\n\n/**\n * @ignore\n * @param {?} backendFactory\n * @param {?} zone\n * @param {?} context\n * @param {?=} backendOptions\n * @param {?=} debugMode\n * @return {?}\n */\n// @dynamic\n\n\nfunction managerFactory(backendFactory, zone, context, backendOptions, debugMode) {\n  backendFactory = unpackBackendForEs5Users(backendFactory);\n  return zone.runOutsideAngular(\n  /**\n  * @return {?}\n  */\n  () => createDragDropManager(backendFactory, context, backendOptions, debugMode));\n}\n/**\n * @ignore\n * @param {?} manager\n * @return {?}\n */\n// @dynamic\n\n\nfunction getBackend(manager) {\n  return manager.getBackend();\n}\n/**\n * @ignore\n * @return {?}\n */\n\n\nfunction getGlobalContext() {\n  return typeof global !== 'undefined' ? global :\n  /** @type {?} */\n  window;\n}\n/**\n * Used for providing backends to {\\@link SkyhookDndModule#forRoot}. You can configure your backend with `options`.\n * @record\n */\n\n\nfunction BackendInput() {}\n\nif (false) {\n  /**\n   * A plain backend, for example the HTML5Backend.\n   * @type {?}\n   */\n  BackendInput.prototype.backend;\n  /**\n   * Any configuration your backend accepts. Use this with the TouchBackend or the MultiBackend, for example.\n   * @type {?|undefined}\n   */\n\n  BackendInput.prototype.options;\n  /**\n   * Whether dnd-core should enable debugging, which lets you see dnd-core actions in the Redux extension for Chrome.\n   * @type {?|undefined}\n   */\n\n  BackendInput.prototype.debug;\n}\n/**\n * DEPRECATED / \\@deprecated\n *\n * To configure backends, prefer using the new `{ backend: SomeBackend, options: { ... } }` pattern.\n * This used to be necessary for configuring backends in AOT mode, but with the new API, it is completely unnecessary.\n *\n * This would be more aptly named as 'backendFactoryFactory'. Example:\n *\n * ```typescript\n * // must export for use with Angular's AOT compilation.\n * export function MyBackendFactory(): BackendFactory {\n *     return (manager, context) => SomeBackend({ options: \"here\" })(manager, context);\n * }\n * forRoot({ backendFactory: MyBackendFactory })\n * ```\n * @record\n */\n\n\nfunction BackendFactoryInput() {}\n\nif (false) {\n  /**\n   * DEPRECATED / \\@deprecated\n   *\n   * To configure backends, prefer using the new `{ backend: SomeBackend, options: { ... } }` pattern. See {\\@link BackendFactoryInput}\n   * @type {?}\n   */\n  BackendFactoryInput.prototype.backendFactory;\n  /**\n   * Whether dnd-core should enable debugging, which lets you see dnd-core actions in the Redux extension for Chrome.\n   * @type {?|undefined}\n   */\n\n  BackendFactoryInput.prototype.debug;\n} // @dynamic\n\n\nlet SkyhookDndModule = /*#__PURE__*/(() => {\n  class SkyhookDndModule {\n    /**\n     * @param {?} backendOrBackendFactory\n     * @return {?}\n     */\n    static forRoot(backendOrBackendFactory) {\n      return {\n        ngModule: SkyhookDndModule,\n        providers: [{\n          provide: DRAG_DROP_BACKEND_FACTORY,\n          // whichever one they have provided, the other will be undefined\n          useValue:\n          /** @type {?} */\n          backendOrBackendFactory.backend,\n          useFactory:\n          /** @type {?} */\n          backendOrBackendFactory.backendFactory\n        }, {\n          provide: DRAG_DROP_BACKEND_OPTIONS,\n          // whichever one they have provided, the other will be undefined\n          useValue:\n          /** @type {?} */\n          backendOrBackendFactory.options\n        }, {\n          provide: DRAG_DROP_BACKEND_DEBUG_MODE,\n          // whichever one they have provided, the other will be undefined\n          useValue: backendOrBackendFactory.debug\n        }, {\n          provide: DRAG_DROP_GLOBAL_CONTEXT,\n          useFactory: getGlobalContext\n        }, {\n          provide: DRAG_DROP_MANAGER,\n          useFactory: managerFactory,\n          deps: [DRAG_DROP_BACKEND_FACTORY, NgZone, DRAG_DROP_GLOBAL_CONTEXT, DRAG_DROP_BACKEND_OPTIONS, DRAG_DROP_BACKEND_DEBUG_MODE]\n        }, {\n          provide: DRAG_DROP_BACKEND,\n          deps: [DRAG_DROP_MANAGER],\n          useFactory: getBackend\n        }, SkyhookDndService]\n      };\n    }\n\n  }\n\n  SkyhookDndModule.Éµfac = function SkyhookDndModule_Factory(t) {\n    return new (t || SkyhookDndModule)();\n  };\n\n  SkyhookDndModule.Éµmod = /*@__PURE__*/Éµngcc0.ÉµÉµdefineNgModule({\n    type: SkyhookDndModule\n  });\n  SkyhookDndModule.Éµinj = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjector({});\n  return SkyhookDndModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && Éµngcc0.ÉµÉµsetNgModuleScope(SkyhookDndModule, {\n    declarations: [DragSourceDirective, DropTargetDirective, DragPreviewDirective],\n    exports: [DragSourceDirective, DropTargetDirective, DragPreviewDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { DRAG_DROP_BACKEND, DRAG_DROP_MANAGER, DragPreviewDirective, DragSourceDirective, DropTargetDirective, SkyhookDndModule, SkyhookDndService, managerFactory as Éµa, getBackend as Éµb, getGlobalContext as Éµc, DRAG_DROP_BACKEND_FACTORY as Éµd, DRAG_DROP_BACKEND_OPTIONS as Éµe, DRAG_DROP_BACKEND_DEBUG_MODE as Éµf, DRAG_DROP_GLOBAL_CONTEXT as Éµg, DndDirective as Éµh }; //# sourceMappingURL=angular-skyhook-core.js.map","map":null,"metadata":{},"sourceType":"module"}